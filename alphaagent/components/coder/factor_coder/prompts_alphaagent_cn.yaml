evaluator_code_feedback_v1_system: |-
  用户正在尝试在以下场景中通过表达式实现一些因子：
  {{ scenario }}

  **仅允许在表达式中使用以下操作：**
  ### **横截面函数**
  - **RANK(A)**：A 在横截面维度中每个元素的排名。
  - **ZSCORE(A)**：A 在横截面维度中每个元素的 Z 分数。
  - **MEAN(A)**：A 在横截面维度中每个元素的平均值。
  - **STD(A)**：A 在横截面维度中的标准差。
  - **SKEW(A)**：A 在横截面维度中的偏度。
  - **KURT(A)**：A 在横截面维度中的峰度。
  - **MAX(A)**：A 在横截面维度中的最大值。
  - **MIN(A)**：A 在横截面维度中的最小值。
  - **MEDIAN(A)**：A 在横截面维度中的中位数。
  - **SCALE(A, target_sum)**：在横截面中将绝对值缩放为和等于 target_sum。

  ### **时间序列函数**
  - **DELTA(A, n)**：A 在 n 个周期内的变化。
  - **DELAY(A, n)**：A 延迟 n 期的值。
  - **TS_MEAN(A, n)**：序列 A 在过去 n 天的平均值。
  - **TS_SUM(A, n)**：序列 A 在过去 n 天的总和。
  - **TS_RANK(A, n)**：A 在过去 n 天最后一个值的时间序列排名。
  - **TS_ZSCORE(A, n)**：序列 A 在过去 n 天的 Z 分数。
  - **TS_MEDIAN(A, n)**：序列 A 在过去 n 天的中位数。
  - **TS_PCTCHANGE(A, p)**：序列 A 在 p 个周期内的百分比变化。
  - **TS_MIN(A, n)**：A 在过去 n 天的最小值。
  - **TS_MAX(A, n)**：A 在过去 n 天的最大值。
  - **TS_ARGMAX(A, n)**：A 在过去 n 天最大值相对当前时间的索引。
  - **TS_ARGMIN(A, n)**：A 在过去 n 天最小值相对当前时间的索引。
  - **TS_QUANTILE(A, p, q)**：序列 A 在过去 p 期的滚动分位数，其中 q 为 0 到 1 的分位值。
  - **TS_STD(A, n)**：序列 A 在过去 n 天的标准差。
  - **TS_VAR(A, p)**：序列 A 在过去 p 期的滚动方差。
  - **TS_CORR(A, B, n)**：序列 A 与 B 在过去 n 天的相关系数。
  - **TS_COVARIANCE(A, B, n)**：序列 A 与 B 在过去 n 天的协方差。
  - **TS_MAD(A, n)**：序列 A 在过去 n 天的滚动中位数绝对偏差。
  - **PERCENTILE(A, q, p)**：序列 A 的分位数，其中 q 为 0 到 1 的分位值。若提供 p，则计算过去 p 期的滚动分位数。
  - **HIGHDAY(A, n)**：过去 n 天内 A 达到最高值距今天的天数。
  - **LOWDAY(A, n)**：过去 n 天内 A 达到最低值距今天的天数。
  - **SUMAC(A, n)**：A 在过去 n 天的累计和。

  ### **移动平均与平滑函数**
  - **SMA(A, n, m)**：A 的 n 期简单移动平均，带修正参数 m。
  - **WMA(A, n)**：A 的 n 期加权移动平均，权重从 0.9 递减至 0.9^(n)。
  - **EMA(A, n)**：A 的 n 期指数移动平均，衰减因子为 2/(n+1)。
  - **DECAYLINEAR(A, d)**：A 的 d 期线性加权移动平均，权重从 1 递增至 d。

  ### **数学运算**
  - **PROD(A, n)**：A 在过去 n 天的乘积。一般乘法用 `*`。
  - **LOG(A)**：A 中每个元素的自然对数。
  - **SQRT(A)**：A 中每个元素的平方根。
  - **POW(A, n)**：将 A 中每个元素提升到 n 次幂。
  - **SIGN(A)**：A 中每个元素的符号，取 1、0 或 -1。
  - **EXP(A)**：A 中每个元素的指数。
  - **ABS(A)**：A 的绝对值。
  - **MAX(A, B)**：A 与 B 的最大值。
  - **MIN(A, B)**：A 与 B 的最小值。
  - **INV(A)**：序列 A 中每个元素的倒数 (1/x)。
  - **FLOOR(A)**：序列 A 中每个元素向下取整。
  
  ### **条件与逻辑函数**
  - **COUNT(C, n)**：过去 n 期中满足条件 C 的样本数。C 为逻辑表达式，如 `$close > $open`。
  - **SUMIF(A, n, C)**：过去 n 期中满足条件 C 的 A 的和。C 为逻辑表达式。
  - **FILTER(A, C)**：按条件 C 过滤多列序列 A。C 为与 A 同尺寸的逻辑表达式。
  - **(C1)&&(C2)**：逻辑"与"。C1 与 C2 为逻辑表达式，如 A > B。
  - **(C1)||(C2)**：逻辑"或"。C1 与 C2 为逻辑表达式，如 A > B。
  - **(C1)?(A):(B)**：条件判断：若 C1 成立则为 A，否则为 B。C1 为逻辑表达式，如 A > B。

  ### **回归与残差函数**
  - **SEQUENCE(n)**：长度为 n 的单列序列，从 1 到整数 n。`SEQUENCE()` 应始终作为 `REGBETA()` 或 `REGRESI()` 的参数 B 嵌套使用。
  - **REGBETA(A, B, n)**：用过去 n 个样本对 A 关于 B 的回归系数，A 必须为多列序列，B 为单列或多列序列。
  - **REGRESI(A, B, n)**：用过去 n 个样本对 A 关于 B 的回归残差，A 必须为多列序列，B 为单列或多列序列。

  ### **技术指标**
  - **RSI(A, n)**：序列 A 在 n 期的相对强弱指数。通过比较近期涨跌幅度衡量动量。
  - **MACD(A, short_window, long_window)**：序列 A 的 MACD，为短期与长期指数移动平均之差。
  - **BB_MIDDLE(A, n)**：布林带中轨，为序列 A 的 n 期简单移动平均。
  - **BB_UPPER(A, n)**：布林带上轨，为中轨加上序列 A 的 n 期两倍标准差。
  - **BB_LOWER(A, n)**：布林带下轨，为中轨减去序列 A 的 n 期两倍标准差。

  注意：
  - 仅允许使用数据中提供的变量（如 `$open`）、算术运算符（`+, -, *, /`）、逻辑运算符（`&&, ||`）以及上述操作。
  - 确保因子表达式至少包含一个数据框列变量（如 `$open`），并结合上述注册操作。不要使用任何未声明变量（如 `n`、`w_1`）和未定义符号（如 `=`）。
  - 注意区分带 TS 前缀的操作（如 `TS_STD()`）与不带前缀的操作（如 `STD()`）。

  用户将向你提供因子的信息。

  你的工作是检查用户的因子表达式是否与因子描述一致，以及因子是否能够正确计算。因子表达式被渲染到 Python Jinja2 模板中然后被执行。如果执行失败，用户将向你提供执行错误消息。

  你的批评应检查用户的因子表达式传达的含义是否与因子描述含义相似。因子公式与表达式之间的细微差异是可以接受的。例如，窗口大小或非核心元素实现的差异是可以的。不需要过度挑剔。

  注意，你的批评不是供用户调试表达式。它们将发送给编码代理以更正表达式。所以不要给用户任何后续项，如"请检查代码第 XXX 行"。

  你的建议不应包含任何代码，仅包含一些清晰简明的建议。请在回复中指出表达式中非常关键的问题，忽略不重要的问题以避免混淆。

  如果表达式中未发现大问题，你需要回复"未发现批评"，不包含任何其他批评。

  你应为每条批评提供建议以帮助用户改进表达式。请按以下格式回复批评。以下是输出的示例结构：
  批评 1：对批评 1 的批评消息
  批评 2：对批评 2 的批评消息

evaluator_code_feedback_v1_user: |-
  ----------------------因子信息：----------------------
  {{ factor_information }}
  ----------------------Python 模板中的因子表达式：----------------------
  {{ code }}
  ----------------------执行反馈：----------------------
  {{ execution_feedback }}
  {% if value_feedback is not none %}
  ----------------------因子值反馈：----------------------
  {{ value_feedback }}
  {% endif %}
  {% if gt_code is not none %}
  ----------------------基准代码：----------------------
  {{ gt_code }}
  {% endif %}

evolving_strategy_factor_implementation_v1_system: |-
  用户正在尝试通过编写因子表达式在以下场景中实现一些因子：
  {{ scenario }}

  可执行的因子表达式应与因子描述一致，如果可能的话使用可用数据和操作来实现。

  为帮助你编写正确的表达式，用户可能会提供多种有助于编写正确表达式的信息：
  1. 用户可能向你提供类似因子的正确表达式。你应从这些表达式中学习以编写正确的表达式。
  2. 用户可能向你提供失败的前一表达式及对应的反馈。反馈包含执行、表达式和因子值。你应分析反馈并尝试更正最新表达式。
  3. 用户可能向你提供对最新失败表达式的建议和一些类似的失败到更正对。每对包含具有类似错误的失败表达式及对应的更正版本表达式。你应从这些建议中学习以编写正确的表达式。
  4. 代码片段的其他部分是固定的 Jinja2 模板。你的响应中的表达式将替换前一个并被执行。

  **你的任务是基于下方你的前一最新尝试来更正或重写你的表达式，该尝试包含你的前一表达式和代码反馈。**

  **仅允许在表达式中使用以下操作：**
  ### **横截面函数**
  - **RANK(A)**：A 在横截面维度中每个元素的排名。
  - **ZSCORE(A)**：A 在横截面维度中每个元素的 Z 分数。
  - **MEAN(A)**：A 在横截面维度中每个元素的平均值。
  - **STD(A)**：A 在横截面维度中的标准差。
  - **SKEW(A)**：A 在横截面维度中的偏度。
  - **KURT(A)**：A 在横截面维度中的峰度。
  - **MAX(A)**：A 在横截面维度中的最大值。
  - **MIN(A)**：A 在横截面维度中的最小值。
  - **MEDIAN(A)**：A 在横截面维度中的中位数。
  - **SCALE(A, target_sum)**：在横截面中将绝对值缩放为和等于 target_sum。

  ### **时间序列函数**
  - **DELTA(A, n)**：A 在 n 个周期内的变化。
  - **DELAY(A, n)**：A 延迟 n 期的值。
  - **TS_MEAN(A, n)**：序列 A 在过去 n 天的平均值。
  - **TS_SUM(A, n)**：序列 A 在过去 n 天的总和。
  - **TS_RANK(A, n)**：A 在过去 n 天最后一个值的时间序列排名。
  - **TS_ZSCORE(A, n)**：序列 A 在过去 n 天的 Z 分数。
  - **TS_MEDIAN(A, n)**：序列 A 在过去 n 天的中位数。
  - **TS_PCTCHANGE(A, p)**：序列 A 在 p 个周期内的百分比变化。
  - **TS_MIN(A, n)**：A 在过去 n 天的最小值。
  - **TS_MAX(A, n)**：A 在过去 n 天的最大值。
  - **TS_ARGMAX(A, n)**：A 在过去 n 天最大值相对当前时间的索引。
  - **TS_ARGMIN(A, n)**：A 在过去 n 天最小值相对当前时间的索引。
  - **TS_QUANTILE(A, p, q)**：序列 A 在过去 p 期的滚动分位数，其中 q 为 0 到 1 的分位值。
  - **TS_STD(A, n)**：序列 A 在过去 n 天的标准差。
  - **TS_VAR(A, p)**：序列 A 在过去 p 期的滚动方差。
  - **TS_CORR(A, B, n)**：序列 A 与 B 在过去 n 天的相关系数。
  - **TS_COVARIANCE(A, B, n)**：序列 A 与 B 在过去 n 天的协方差。
  - **TS_MAD(A, n)**：序列 A 在过去 n 天的滚动中位数绝对偏差。
  - **PERCENTILE(A, q, p)**：序列 A 的分位数，其中 q 为 0 到 1 的分位值。若提供 p，则计算过去 p 期的滚动分位数。
  - **HIGHDAY(A, n)**：过去 n 天内 A 达到最高值距今天的天数。
  - **LOWDAY(A, n)**：过去 n 天内 A 达到最低值距今天的天数。
  - **SUMAC(A, n)**：A 在过去 n 天的累计和。

  ### **移动平均与平滑函数**
  - **SMA(A, n, m)**：A 的 n 期简单移动平均，带修正参数 m。
  - **WMA(A, n)**：A 的 n 期加权移动平均，权重从 0.9 递减至 0.9^(n)。
  - **EMA(A, n)**：A 的 n 期指数移动平均，衰减因子为 2/(n+1)。
  - **DECAYLINEAR(A, d)**：A 的 d 期线性加权移动平均，权重从 1 递增至 d。

  ### **数学运算**
  - **PROD(A, n)**：A 在过去 n 天的乘积。一般乘法用 `*`。
  - **LOG(A)**：A 中每个元素的自然对数。
  - **SQRT(A)**：A 中每个元素的平方根。
  - **POW(A, n)**：将 A 中每个元素提升到 n 次幂。
  - **SIGN(A)**：A 中每个元素的符号，取 1、0 或 -1。
  - **EXP(A)**：A 中每个元素的指数。
  - **ABS(A)**：A 的绝对值。
  - **MAX(A, B)**：A 与 B 的最大值。
  - **MIN(A, B)**：A 与 B 的最小值。
  - **INV(A)**：序列 A 中每个元素的倒数 (1/x)。
  - **FLOOR(A)**：序列 A 中每个元素向下取整。
  
  ### **条件与逻辑函数**
  - **COUNT(C, n)**：过去 n 期中满足条件 C 的样本数。C 为逻辑表达式，如 `$close > $open`。
  - **SUMIF(A, n, C)**：过去 n 期中满足条件 C 的 A 的和。C 为逻辑表达式。
  - **FILTER(A, C)**：按条件 C 过滤多列序列 A。C 为与 A 同尺寸的逻辑表达式。
  - **(C1)&&(C2)**：逻辑"与"。C1 与 C2 为逻辑表达式，如 A > B。
  - **(C1)||(C2)**：逻辑"或"。C1 与 C2 为逻辑表达式，如 A > B。
  - **(C1)?(A):(B)**：条件判断：若 C1 成立则为 A，否则为 B。C1 为逻辑表达式，如 A > B。

  ### **回归与残差函数**
  - **SEQUENCE(n)**：长度为 n 的单列序列，从 1 到整数 n。`SEQUENCE()` 应始终作为 `REGBETA()` 或 `REGRESI()` 的参数 B 嵌套使用。
  - **REGBETA(A, B, n)**：用过去 n 个样本对 A 关于 B 的回归系数，A 必须为多列序列，B 为单列或多列序列。
  - **REGRESI(A, B, n)**：用过去 n 个样本对 A 关于 B 的回归残差，A 必须为多列序列，B 为单列或多列序列。

  ### **技术指标**
  - **RSI(A, n)**：序列 A 在 n 期的相对强弱指数。通过比较近期涨跌幅度衡量动量。
  - **MACD(A, short_window, long_window)**：序列 A 的 MACD，为短期与长期指数移动平均之差。
  - **BB_MIDDLE(A, n)**：布林带中轨，为序列 A 的 n 期简单移动平均。
  - **BB_UPPER(A, n)**：布林带上轨，为中轨加上序列 A 的 n 期两倍标准差。
  - **BB_LOWER(A, n)**：布林带下轨，为中轨减去序列 A 的 n 期两倍标准差。

  注意：
  - 仅允许使用数据中提供的变量（如 `$open`）、算术运算符（`+, -, *, /`）、逻辑运算符（`&&, ||`）以及上述操作。
  - 确保因子表达式至少包含一个数据框列变量（如 `$open`），并结合上述注册操作。不要使用任何未声明变量（如 `n`、`w_1`）和未定义符号（如 `=`）。
  - 注意区分带 TS 前缀的操作（如 TS_STD()）与不带前缀的操作（如 `STD()`）。

  请按以下 JSON 格式回复更正后的表达式。以下是 JSON 输出的示例结构：
  {
      "expr": "[更正后的因子表达式]"
  }

evolving_strategy_factor_implementation_v2_user: |-
  ----------------------目标因子信息：----------------------
  {{ factor_information_str }}

  {% if former_expression is not none %}
  ----------------------你的前一最新尝试：----------------------
  =====前一实现的表达式=====
  {{ former_expression }}

  =====对前一实现的反馈=====
  {{ former_feedback }}
  {% endif %}

  {% if queried_similar_error_knowledge|length != 0 %}
  {% if error_summary_critics is none %}
  回顾你上次的失败，你的实现遇到了一些错误。
  在做其他任务时，你遇到了一些相似的错误，但最终解决了。以下是一些示例：
  {% for error_content, similar_error_knowledge in queried_similar_error_knowledge %} 
  ----------------------类似错误的因子信息（{{error_content}}）：----------------------
  {{ similar_error_knowledge[0].target_task.get_task_information() }}
  =====具有相似错误的代码（{{error_content}}）：=====
  {{ similar_error_knowledge[0].implementation.code }}
  =====前一代码的成功代码（具有相似错误）（{{error_content}}）：=====
  {{ similar_error_knowledge[1].implementation.code }}
  {% endfor %}
  {% else %}
  回顾你上次的失败，你的实现遇到了一些错误。
  审查了一些相似的错误及其解决方案后，以下是一些帮助你更正代码的建议：
  {{error_summary_critics}}
  {% endif %}
  {% endif %}
  
  {% if similar_successful_factor_description is not none %}
  以下是一些类似组件任务的成功实现，作为参考：
  ----------------------类似因子的正确代码：----------------------
  =====因子描述：=====
  {{ similar_successful_factor_description }}
  =====因子表达式：=====
  {{ similar_successful_expression }}
  {% endif %}
  {% if latest_attempt_to_latest_successful_execution is not none %}
  你尝试更正之前失败的表达式但仍遇到了一些错误。以下是最新尝试到最新成功执行，尝试不要在你的新代码中犯同样的错误：
  =====你的最新尝试=====
  {{ latest_attempt_to_latest_successful_execution.implementation.code }}
  =====对你的最新尝试的反馈=====
  {{ latest_attempt_to_latest_successful_execution.feedback }}
  {% endif %}

evolving_strategy_error_summary_v2_system: |-
  用户正在尝试在以下场景中实现一些因子：
  {{ scenario }}
  用户正在进行以下任务：
  {{factor_information_str}}

  你已经编写了一些代码，但遇到了如下错误：
  {{code_and_feedback}}

  用户找到了一些遇到相似错误的任务及其最终正确解决方案。
  请参考这些相似的错误及其解决方案，提供一些清晰、简明且准确的批评，可能帮助你解决代码中的问题。

  你的建议不应包含任何代码，仅包含一些清晰简明的建议。请在回复中指出代码中非常关键的问题，忽略不重要的问题以避免混淆。如果代码中未发现大问题，你可回复"未发现批评"。

  请按以下格式回复批评。以下是输出的示例结构：
  批评 1：对批评 1 的批评消息
  批评 2：对批评 2 的批评消息
  
evolving_strategy_error_summary_v2_user: |-
  {% if queried_similar_error_knowledge|length != 0 %}
  {% for error_content, similar_error_knowledge in queried_similar_error_knowledge %} 
  ----------------------类似错误的因子信息（{{error_content}}）：----------------------
  {{ similar_error_knowledge[0].target_task.get_task_information() }}
  =====具有相似错误的代码（{{error_content}}）：=====
  {{ similar_error_knowledge[0].implementation.code }}
  =====前一代码的成功代码（具有相似错误）（{{error_content}}）：=====
  {{ similar_error_knowledge[1].implementation.code }}
  {% endfor %}
  {% endif %}


select_implementable_factor_system: |-
  用户正在尝试在以下场景中实现一些因子：
  {{ scenario }}
  你的工作是帮助用户选择最容易实现的因子。由于缺乏信息或过度复杂，某些因子可能难以实现。用户将提供你应该选择的因子数量和因子信息，包括它们的描述、公式和变量解释。
  用户将向你提供前一次实现因子的尝试及其反馈。你需要仔细审查你以前的尝试。某些因子已被反复尝试但未成功。你应考虑放弃这些因子。
  请分析每个因子的难度和提供原因，并以 JSON 格式回复所选可实现因子的索引。以下是 JSON 输出的示例结构：
  {
      "Analysis": "分析每个因子的难度并提供原因说明该因子是否可以实现。"
      "selected_factor": "所选因子索引的列表，如 [0, 2, 3]。长度应为过滤后剩余的因子数。",
  }

select_implementable_factor_user: |-
  你应该选择的因子数量：{{ factor_num }}
  {% for factor_info in sub_tasks %} 
  =============因子索引：{{factor_info[0]}}：=============
  =====因子名称：=====
  {{ factor_info[1].factor_name }}
  =====因子描述：=====
  {{ factor_info[1].factor_description }}
  =====因子公式：=====
  {{ factor_info[1].factor_formulation }}
  {% if factor_info[2]|length != 0 %}
  ----------------------你的前一次尝试：----------------------
  {% for former_attempt in factor_info[2] %}
  =====尝试 {{ loop.index }} 的代码=====
  {{ former_attempt.implementation.code }}
  =====尝试 {{ loop.index }} 的反馈=====
  {{ former_attempt.feedback }}
  {% endfor %}
  {% endif %}
  {% endfor %}

evaluator_output_format_system: |-
  用户正在尝试在以下场景中实现一些因子：
  {{ scenario }}
  用户将向你提供输出的格式。请帮助检查输出是否与格式相符。
  请以 JSON 格式回复。以下是 JSON 输出的示例结构：
  {
      "output_format_decision": true,
      "output_format_feedback": "输出格式正确。"
  }


evaluator_final_decision_v1_system: |-
  用户正在尝试在以下场景中实现一些因子：
  {{ scenario }}
  用户已完成评估并从评估器获得了一些反馈。
  评估器运行代码并获得因子值数据框，并提供关于用户代码和代码输出的多条反馈。你应分析反馈，考虑场景和因子描述，以对评估结果给出最终决定。最终决定包括因子是否被正确实现，如果不是，则详细反馈包含原因和建议。

  实现被认为是正确的，如果代码执行成功（假设提供的数据正确）。任何异常，包括主动引发的异常，都被认为是代码的错误。此外，代码反馈必须与场景和因子描述相符。

  请以 JSON 格式回复批评，不包含任何其他内容。以下是 JSON 输出的示例结构，请严格遵循格式：
  {
      "final_decision": true,
      "final_feedback": "最终反馈消息，单行文本",
  }

evaluator_final_decision_v1_user: |-
  ----------------------因子信息：----------------------
  {{ factor_information }}
  ----------------------执行反馈：----------------------
  {{ execution_feedback }}
  ----------------------代码反馈：----------------------
  {{ code_feedback }}
  ----------------------因子值反馈：----------------------
  {{ value_feedback }}


function_lib_description: |-
  （不要在你的表达式中使用任何未声明的变量（如 `n`）。仅允许使用数据中提供的变量（如 `$open`）、算术运算符（`+, -, *, /`）、逻辑运算符（`&&, ||`）以及以下操作：
  以下操作允许在表达式中使用：
  ### **排名与归一化函数**
  - **RANK(A)**：A 在横截面维度中每个元素的排名。
  - **ZSCORE(A)**：A 在横截面维度中每个元素的 Z 分数。
  - **MEAN(A)**：A 在横截面维度中每个元素的平均值。
  - **STD(A)**：A 在横截面维度中的标准差。
  - **SKEW(A)**：A 在横截面维度中的偏度。
  - **KURT(A)**：A 在横截面维度中的峰度。
  - **MAX(A)**：A 在横截面维度中的最大值。
  - **MIN(A)**：A 在横截面维度中的最小值。
  - **MEDIAN(A)**：A 在横截面维度中的中位数。
  - **SCALE(A, target_sum)**：在横截面中将绝对值缩放为和等于 target_sum。
  - **TS_RANK(A, n)**：A 在过去 n 天最后一个值的时间序列排名。
  - **TS_ZSCORE(A, n)**：序列 A 在过去 n 天的 Z 分数。

  ### **统计函数**
  - **TS_STD(A, n)**：序列 A 在过去 n 天的标准差。
  - **TS_VAR(A, p)**：序列 A 在过去 p 期的滚动方差。
  - **TS_CORR(A, B, n)**：序列 A 与 B 在过去 n 天的相关系数。
  - **TS_COVARIANCE(A, B, n)**：序列 A 与 B 在过去 n 天的协方差。
  - **PERCENTILE(A, q, p)**：序列 A 的分位数，其中 q 为 0 到 1 的分位值。若提供 p，则计算过去 p 期的滚动分位数。

  ### **时间序列函数**
  - **DELTA(A, n)**：A 在 n 个周期内的变化。
  - **DELAY(A, n)**：A 延迟 n 期的值。
  - **TS_MEAN(A, n)**：序列 A 在过去 n 天的平均值。
  - **TS_SUM(A, n)**：序列 A 在过去 n 天的总和。
  - **TS_MEDIAN(A, n)**：序列 A 在过去 n 天的中位数。
  - **TS_MAD(A, n)**：序列 A 在过去 n 天的滚动中位数绝对偏差。
  - **TS_PCTCHANGE(A, p)**：序列 A 在 p 个周期内的百分比变化。
  - **TS_MIN(A, n)**：A 在过去 n 天的最小值。
  - **TS_MAX(A, n)**：A 在过去 n 天的最大值。
  - **TS_ARGMAX(A, n)**：A 在过去 n 天最大值相对当前时间的索引。
  - **TS_ARGMIN(A, n)**：A 在过去 n 天最小值相对当前时间的索引。
  - **TS_QUANTILE(A, p, q)**：序列 A 在过去 p 期的滚动分位数，其中 q 为 0 到 1 的分位值。
  - **HIGHDAY(A, n)**：过去 n 天内 A 达到最高值距今天的天数。
  - **LOWDAY(A, n)**：过去 n 天内 A 达到最低值距今天的天数。
  - **SUMAC(A, n)**：A 在过去 n 天的累计和。

  ### **移动平均与平滑函数**
  - **SMA(A, n, m)**：A 的 n 期简单移动平均，带修正参数 m。
  - **WMA(A, n)**：A 的 n 期加权移动平均，权重从 0.9 递减至 0.9^(n)。
  - **EMA(A, n)**：A 的 n 期指数移动平均，衰减因子为 2/(n+1)。
  - **DECAYLINEAR(A, d)**：A 的 d 期线性加权移动平均，权重从 1 递增至 d。

  ### **数学运算**
  - **PROD(A, n)**：A 在过去 n 天的乘积。一般乘法用 `*`。
  - **LOG(A)**：A 中每个元素的自然对数。
  - **SQRT(A)**：A 中每个元素的平方根。
  - **POW(A, n)**：将 A 中每个元素提升到 n 次幂。
  - **SIGN(A)**：A 中每个元素的符号，取 1、0 或 -1。
  - **EXP(A)**：A 中每个元素的指数。
  - **ABS(A)**：A 的绝对值。
  - **MAX(A, B)**：A 与 B 的最大值。
  - **MIN(A, B)**：A 与 B 的最小值。
  - **INV(A)**：序列 A 中每个元素的倒数 (1/x)。
  - **ADD(A, B)**：逐元素将 A 和 B 相加。
  - **SUBTRACT(A, B)**：逐元素从 A 减去 B。
  - **MULTIPLY(A, B)**：逐元素将 A 和 B 相乘。
  - **DIVIDE(A, B)**：逐元素将 A 除以 B。
  - **AND(A, B)**：A 和 B 之间的逻辑与运算。
  - **OR(A, B)**：A 和 B 之间的逻辑或运算。

  ### **条件与逻辑函数**
  - **COUNT(C, n)**：过去 n 期中满足条件 C 的样本数。C 为逻辑表达式，如 `$close > $open`。
  - **SUMIF(A, n, C)**：过去 n 期中满足条件 C 的 A 的和。C 为逻辑表达式。
  - **FILTER(A, C)**：按条件 C 过滤多列序列 A。C 为与 A 同尺寸的逻辑表达式。
  - **(C1)&&(C2)**：逻辑"与"。C1 与 C2 为逻辑表达式，如 A > B。
  - **(C1)||(C2)**：逻辑"或"。C1 与 C2 为逻辑表达式，如 A > B。
  - **(C1)?(A):(B)**：条件判断：若 C1 成立则为 A，否则为 B。C1 为逻辑表达式，如 A > B。

  ### **回归与残差函数**
  - **SEQUENCE(n)**：长度为 n 的单列序列，从 1 到整数 n。`SEQUENCE()` 应始终作为 `REGBETA()` 或 `REGRESI()` 的参数 B 嵌套使用。
  - **REGBETA(A, B, n)**：用过去 n 个样本对 A 关于 B 的回归系数，A 必须为多列序列，B 为单列或多列序列。
  - **REGRESI(A, B, n)**：用过去 n 个样本对 A 关于 B 的回归残差，A 必须为多列序列，B 为单列或多列序列。

  ### **技术指标**
  - **RSI(A, n)**：序列 A 在 n 期的相对强弱指数。通过比较近期涨跌幅度衡量动量。
  - **MACD(A, short_window, long_window)**：序列 A 的 MACD，为短期与长期指数移动平均之差。
  - **BB_MIDDLE(A, n)**：布林带中轨，为序列 A 的 n 期简单移动平均。
  - **BB_UPPER(A, n)**：布林带上轨，为中轨加上序列 A 的 n 期两倍标准差。
  - **BB_LOWER(A, n)**：布林带下轨，为中轨减去序列 A 的 n 期两倍标准差。