hypothesis_and_feedback: |-
  {% for hypothesis, experiment, feedback in trace.hist[-10:] %}
  假设 {{ loop.index }}：{{ hypothesis }}
  对应代码（导致性能差异）：{{experiment.sub_workspace_list[0].code_dict.get("model.py")}}
  基于该假设的结果观察：{{ feedback.observations }}
  对原始假设的反馈：{{ feedback.hypothesis_evaluation }}
  用于上下文的新反馈（供你同意或改进）：{{ feedback.new_hypothesis }}
  新假设的理由：{{ feedback.reason }}
  变更到该假设是否有效？（关注变化）：{{ feedback.decision }}
  {% endfor %}

hypothesis_output_format: |-
  输出必须为 JSON 格式，不包含其他内容。结构如下：
  {
  "hypothesis": "基于提供信息生成的新假设。",
  "reason": "生成该假设的原因。应全面且有逻辑，涵盖下方其他键并进行扩展。",
  "concise_reason": "两行总结。第一行聚焦于变更的简要论证；第二行总结可迁移知识。",
  "concise_observation": "单行总结。聚焦于给定情景、数据特征或以往经验（失败与成功）的观察。",
  "concise_justification": "单行总结。基于理论原则或初始假设为该假设进行论证。",
  "concise_knowledge": "单行总结。基于理论原则的可迁移知识。使用条件语法，如：'如果……，……；当……，……；等等'。确保表达清晰无歧义。例如，避免说“先前的假设”，因为读者不知道指什么。"
  }



model_hypothesis_specification: |-
  额外规范：
    
    假设应基于之前的假设逐步演化与增长。若无先前假设，从简单开始。逐轮在前一假设与反馈基础上逐步构建。每一轮假设都应不同。注意你之前的假设。

    确保假设聚焦于 PyTorch 模型的架构。每个假设应针对具体的架构选择，如层类型、激活函数、正则化技术和整体结构。避免与输入特征或优化过程相关的假设。

  记住：若没有假设，从类似 MLP 这样简单的开始。

  通常较大的模型比小模型更好。

  生成新假设的逻辑：若之前的假设有效，继承并加深；若无效，在当前层级进行调整。

  假设演化示例（完整流程，看看当前阶段。希望假设持续增长）。层级包括 **模型类型**、**层配置**、**激活函数**、**正则化技术**

    第 1 轮假设：模型应为 CNN。

    第 2 轮假设（若第 1 轮有效：CNN 属于模型类型层级，需扩展到下一级，如层配置）：模型应为 CNN。CNN 应有 5 个卷积层。（理由：CNN 有效，因此细化层配置以加深假设。）

    第 3 轮假设（若第 2 轮无效）：模型应为 CNN。CNN 应有 3 个卷积层。（理由：第 2 轮的 5 层结构无效，尝试同一层级内的替代。）

    第 4 轮假设（若第 3 轮有效）：模型应为 CNN。CNN 应有 3 个卷积层。所有层使用 Leaky ReLU 激活。（上一轮有效，进入下一层级：激活函数）

    第 5 轮假设（若第 4 轮有效）：模型应为 CNN。CNN 应有 3 个卷积层。所有层使用 Leaky ReLU 激活。使用 dropout 正则化，比例 0.5。（类似推理，继续增长至 dropout 配置）

    第 6 轮假设（若第 4 轮无效）：模型应为 CNN。CNN 应有 5 个卷积层。所有层使用 Leaky ReLU 激活。使用 dropout 正则化，比例 0.3。（理由：0.5 的正则化率无效，仅调整当前层级的正则化并保留其他有效元素。）    

factor_hypothesis_specification: |-
  1. **因子类型与金融趋势：**
    - 定义引入的因子类型。
    - 解释该因子指示的金融趋势或市场行为。
    - 省略不必要或冗余细节。

  2. **先简单且有效的因子：**
    - 从简单且可能有效的因子开始。
    - 简明解释这些因子为何可能有效。
    - 初期避免复杂或组合型因子。

  3. **逐步提高复杂度：**
    - 随着更多实验结果的积累，引入更复杂的因子。
    - 讨论潜在优势与复杂性。
    - 仅在简单因子测试并验证后再进行组合。

  4. **新方向与优化：**
    - 如需新方向，基于金融原理、经济理论或市场行为解释原因。
    - 为清晰起见，每次仅建议一个新方向。
    - 若先前假设未超越 SOTA 但可优化，可继续同一方向。
    - 强调超越 SOTA 的因子已纳入库中，避免重复实现。

  5. **每次生成 1-2 个因子：**
    - 每次生成 1-2 个因子。
    - 在简单与复杂之间平衡，构建稳健因子库。

factor_experiment_output_format: |-
  输出必须为 JSON 格式，不包含其他内容。结构如下：
  {
      "factor name 1": {
          "description": "因子 1 的描述",
          "formulation": "因子 1 的 LaTeX 公式",
          "variables": {
              "变量或函数名 1": "变量或函数 1 的描述",
              "变量或函数名 2": "变量或函数 2 的描述"
          }
      },
      "factor name 2": {
          "description": "因子 1 的描述",
          "formulation": "因子 2 的 LaTeX 公式",
          "variables": {
              "变量或函数名 1": "变量或函数 1 的描述",
              "变量或函数名 2": "变量或函数 2 的描述"
          }
      }
      # 不要在此添加省略号 (...) 或任何可能导致 JSON 解析错误的占位文本！
  }

model_experiment_output_format: |-
  目前请仅设计一个模型来测试该假设！
  输出必须为 JSON 格式。结构如下：
  {
    "model_name 1 (模型名称)": {
        "description": "对模型的详细描述",
        "formulation": "表示模型公式的 LaTeX 公式",
        "architecture": "模型架构的详细描述，如神经网络层或树结构",
        "variables": {
            "\\hat{y}_u": "节点 u 的预测输出",
            "variable_name_2": "变量 2 的描述",
            "variable_name_3": "变量 3 的描述"
        },
        "hyperparameters": {
            "hyperparameter_name_1": "超参数 1 的值",
            "hyperparameter_name_2": "超参数 2 的值",
            "hyperparameter_name_3": "超参数 3 的值"
        },
        "model_type": "Tabular 或 TimeSeries"  # 必须为 "Tabular" 或 "TimeSeries" 之一
    },
    "model_name 2 (模型名称)": {
        ...
    }
  }
  通常较大的模型比小模型更好。因此参数应更大。

factor_feedback_generation:
  system: |-
    你是一名专业的金融结果分析助手，服务于数据驱动的研发流程。
    任务情景如下：

    {{ scenario }}
    
    你将收到一个假设、多个任务及其因子、结果，以及 SOTA 结果。
    你的反馈应说明当前结果是否支持或反驳该假设，与先前 SOTA（State of the Art）结果对比，并提出改进或新方向建议。
    
    请理解以下操作逻辑，然后给出适合该场景的反馈：
      1. 逻辑说明：
          - 若前一假设因子超越 SOTA，将其纳入 SOTA 因子库。
          - 新实验将生成新因子，与 SOTA 库中的因子组合。
          - 这些组合因子将回测并与当前 SOTA 比较，持续迭代。
      2. 发展方向：
          - 新方向：
              - 提出一个新的因子方向进行探索与发展。
          - 现有方向优化：
              - 若上次实验因子替代 SOTA，建议进一步改进该因子。
              - 清晰说明与前一因子在名称与改进上的差异。
          - 持续研究：
              - 若上次实验因子未替代 SOTA，建议在该方向上继续优化与发展。
      3. 最终目标：
          - 终极目标是持续累积每轮超越的因子，保持最佳 SOTA。
    
      结果判定时：
      1. **替换建议：**
        - 若新因子在不计交易成本的年化收益上显著提升，建议替换当前最佳结果。
        - 若年化收益与任一其他指标优于 SOTA，也建议替换。
        - 只要年化收益提升，其他指标的小幅波动可接受。

    若与 SOTA 差距显著，考虑改变方向：
      - 若新结果与 SOTA 差距明显，考虑探索新方向。
      - 避免重复实现已超越 SOTA 的因子，这些因子已在库中并将用于每次运行。

    请提供详细且建设性的反馈以供后续探索。
    以 JSON 格式回复。结果分析的 JSON 示例结构：
    {
      "Observations": "整体观察",
      "Feedback for Hypothesis": "与假设相关的观察",
      "New Hypothesis": "你的新假设",
      "Reasoning": "新假设的理由",
      "Replace Best Result": "yes 或 no"
    }
  user: |-
    目标假设： 
    {{ hypothesis_text }}
    任务与因子：
    {% for task in task_details %}
      - {{ task.factor_name }}：{{ task.factor_description }}
        - 因子公式：{{ task.factor_formulation }}
        - 变量：{{ task.variables }}
        - 因子实现：{{ task.factor_implementation }}
        {% if task.factor_implementation == "False" %}
        **注意：该因子未在当前实验中实现。只有已实现因子的假设才能在本次运行中验证。**
        {% endif %}
    {% endfor %}
    综合结果： 
    {{ combined_result }}
    
    在以下方面分析综合结果：
    1. 支持或反驳假设。
    2. 与 SOTA 实验相比表现是改进还是退化。

    评估指标说明：
    以下是各指标的金融含义，应据此判断结果：

    - 1day.excess_return_without_cost.max_drawdown：不考虑交易成本的最大回撤（越小越好）
    - 1day.excess_return_without_cost.information_ratio：不考虑交易成本的超额收益风险比（越大越好）
    - 1day.excess_return_without_cost.annualized_return：不考虑交易成本的年化收益（越大越好）
    - IC：预测收益（\hat{y}）与实际收益（y）的相关性，使用皮尔逊相关（越大越好）

    判断结果时：
      1. **替换建议：**
        - 若新因子在不计交易成本的年化收益上显著提升，建议替换当前最佳结果。
        - 若年化收益与任一其他指标优于 SOTA，也建议替换。
        - 只要年化收益提升，其他指标的小幅波动可接受。

    若与 SOTA 差距显著，考虑改变方向：
      - 若新结果与 SOTA 差距明显，考虑探索新方向。
      - 避免重复实现已超越 SOTA 的因子，这些因子已在库中并将用于每次运行。

    注意：只有“因子实现”为 True 的因子在本次实验中被实现与测试。若为 False，则该因子的假设无法在本次运行中验证。

model_feedback_generation:
  system: |-
    你是一名专业的结果分析助手。你将收到一个结果和一个假设。
    你的任务是根据性能提升或下降的观察，反馈结果在多大程度上支持或反驳该假设。
    请提供详细且建设性的反馈。注意随着假设演化，模型通常应更大。
    结果分析的 JSON 示例结构：
    {
      "Observations": "整体观察",
      "Feedback for Hypothesis": "与假设相关的观察",
      "New Hypothesis": "你的新假设",
      "Reasoning": "为该假设提供理由。",
      "Decision": <true or false>,
    }

    聚焦假设变化，并解释假设为何这样演化。同时随着假设演化提高复杂度（更多层、更多神经元等）
    
    生成新假设的逻辑：若之前的假设有效，继承并加深；若无效，在当前层级进行调整。

    假设演化示例（完整流程，看看当前阶段。希望假设持续增长）。层级包括 **模型类型**、**层配置**、**激活函数**、**正则化技术**

      第 1 轮假设：模型应为 CNN。

      第 2 轮假设（若第 1 轮有效：CNN 属于模型类型层级，需扩展到下一级，如层配置）：模型应为 CNN。CNN 应有 5 个卷积层。（理由：CNN 有效，因此细化层配置以加深假设。）

      第 3 轮假设（若第 2 轮无效）：模型应为 CNN。CNN 应有 3 个卷积层。（理由：第 2 轮的 5 层结构无效，尝试同一层级内的替代。）

      第 4 轮假设（若第 3 轮有效）：模型应为 CNN。CNN 应有 3 个卷积层。所有层使用 Leaky ReLU 激活。（上一轮有效，进入下一层级：激活函数）
      
      第 5 轮假设（若第 4 轮有效）：模型应为 CNN。CNN 应有 3 个卷积层。所有层使用 Leaky ReLU 激活。使用 dropout 正则化，比例 0.5。（类似推理，继续增长至 dropout 配置）

      第 6 轮假设（若第 4 轮无效）：模型应为 CNN。CNN 应有 5 个卷积层。所有层使用 Leaky ReLU 激活。使用 dropout 正则化，比例 0.3。（理由：0.5 的正则化率无效，仅调整当前层级的正则化并保留其他有效元素。）    

    
  user: |-
    我们正在进行寻找假设并验证或拒绝它们的实验，最终目标是得到一个强大的模型。
    这里是上下文：{{context}}。

    {% if last_hypothesis %} 
    上一轮信息：
    假设：{{last_hypothesis.hypothesis}}
    任务：{{last_task}}
    已实现代码：{{last_code}}
    结果：{{last_result}}
    {% else %}
    这是第一轮。没有之前的信息。只要性能不是太差（例如 ICIR 大于 0），就视为成功。不要把阈值设得太高。  
    {% endif %} 
    
    现在来到本轮。你将收到结果并评估性能是上升还是下降。
    假设：{{hypothesis.hypothesis}}
    实验设置：{{exp.sub_tasks[0]}}
    已实现代码：{{exp.sub_workspace_list[0].code_dict.get("model.py")}}
    相关推理：{{hypothesis.reason}}
    结果：{{exp.result}}

    比较并观察。哪个结果具有更高回报和更低风险？如果性能提升，则该假设应视为正向（有效）。
    因此，请结合假设、相关推理与结果（对比），提供详细且建设性的反馈，并提出新假设。